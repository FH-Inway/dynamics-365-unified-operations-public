# Creating certificates for the RSAT Certificate based authentication.

In this document we will go over how the user can set up the certificate
needed for RSAT 2.8 Certificate Based Authentication (henceforth: CBA).

**About Certificates**

Digital certificates are essentially digital \"ID cards\" that help
establish trust online. They bind a public key to an entity's identity -
whether it\'s a website, an individual, or an organization - using
cryptography, ensuring secure communication across networks.
Certificates are a fundamental building block in modern security,
forming part of a broader Public Key Infrastructure (PKI) that underpins
secure communications across the internet. They provide a way to verify
identity and establish encrypted channels, helping protect sensitive
data from malicious actors.

Certificates are arranged as trees, with the Root certificate (also
called the CA certificate as explained below) at the top as shown in
this diagram:

 

![Chain of Trust](Media/media/chain-of-trust.png){width="5.0in"
height="2.71875in"}

 

Image credit: [Fanyangxi -- CC BY-SA
4.0](https://commons.wikimedia.org/wiki/File:Chain_of_trust_v2.svg)

Binding intermediate and user certificates to a securely managed root
certificate not only secures the foundational trust of your PKI but also
makes certificate issuance, management, and eventual revocation more
efficient and resilient to potential security breaches. This layered
approach is core to modern digital security practices and maintains
trust while enabling scalability and flexibility across complex
environments.

 *We need to map the values in the scripts to what is entered into the
RSAT dialog.*

## Creating the Certificates

Certificates are often generated by a certificate authority (aka. CA.
Public CA providers include GoDaddy and Verisign) that will issue
certificates based on the identity of the applicant. You submit a
Certificate Signing Request (CSR) to these providers and in return, they
provide you with an SSL certificate signed using their root certificate
and private key. The certificate has a specified life span. If you have
a certificate from a CA provider, you can use that certificate instead
of creating a self-signed certificate, as we will be illustrating below.
You can also generate certificates from the Active Directory Certificate
Services.

Certificates can also be created using Active Directory Certificate
Services (ADCS). Depending on the domain setup, you maybe able to
generate the required certificates using ADCS, however that is out of
scope for this document.

In this section we will generate the self-signed certificates that we
will need to set up the RSAT system. We will create a root certificate,
an intermediate certificate and a user certificate. We will then proceed
to upload these certificates to Entra and install them on the local box
running RSAT 2.8.

### Creating a Root Certificate

These are also known as Certificate Authority (CA) certificates, the
trusted authority used to generate the certificate. This CA cert is used
to sign any number of intermediate certificates, as described below.

 Here is a PowerShell script to generate a self-signed CA (i.e. root)
certificate for Contoso:

\# Create a Root CA certificate (self-signed)\
\$rootCert = New-SelfSignedCertificate \`\
  -Subject \"CN=ContosoRootCA, O=Contoso, OU=IT, C=US\" \`\
  -KeyExportPolicy Exportable \`\
  -KeyUsage CertSign, CRLSign, DigitalSignature \`\
  -Type Custom \`\
  -KeyAlgorithm RSA \`\
  -KeyLength 2048 \`\
  -HashAlgorithm SHA256 \`\
  -NotAfter (Get-Date).AddYears(10) \`\
  -CertStoreLocation \"Cert:\\LocalMachine\\My\" \`\
  -TextExtension @(\"2.5.29.19={critical}{text}ca=true&pathlength=1\")

Export-Certificate -Cert \$rootCert -FilePath
\"C:\\Temp\\ContosoRootCA.cer\"

Let\'s break down the script and explain what each parameter means:

1.  **Creating the Certificate**

\$rootCert = New-SelfSignedCertificate \`

This line calls the New-SelfSignedCertificate cmdlet and assigns the
generated certificate object to the variable \$rootCert.

2.  **Subject Parameter**

-Subject \"CN=ContosoRootCA, O=Contoso, OU=IT, C=US\" \`

 

The -Subject parameter sets the Distinguished Name (DN) for the
certificate. It contains:

- **CN (Common Name):** \"ContosoRootCA\": The label for the
  certificate, typically used as the primary identifier.

- **O (Organization):** \"Contoso": Indicates the organization.

- **OU (Organizational Unit):** \"IT\": Denotes a specific department or
  division within the organization.

- **C (Country):** \"US\": The country code.

3.  **Key Export Policy**

-KeyExportPolicy Exportable \`

The -KeyExportPolicy parameter determines whether the private key can be
exported. Setting it to Exportable means the private key can be
extracted from the certificate store as needed. 

4.  **Key Usage**

-KeyUsage CertSign, CRLSign, DigitalSignature \`

The -KeyUsage parameter specifies what the certificate's key can be used
for:

- **CertSign:** Allows the certificate to sign other certificates.

- **CRLSign:** Permits signing Certificate Revocation Lists (CRLs).

- **DigitalSignature:** Enables the certificate to be used for creating
  digital signatures.\
  These usages are typical for a Certificate Authority (CA) certificate.

5.  **Type**

-Type Custom \`

The -Type Custom setting indicates that you're creating a certificate
with customized properties, rather than using a predefined template. 

6.  **Key Algorithm**

-KeyAlgorithm RSA \`

This parameter defines the algorithm for creating the key pair. Here,
**RSA** is chosen, which is one of the most widely used public-key
cryptographic algorithms.

7.  **Key Length**

-KeyLength 2048 \`

The -KeyLength parameter sets the size of the cryptographic key in bits.
A 2048-bit key is a common standard offering a strong balance between
security and performance.

8.  **Hash Algorithm**

-HashAlgorithm SHA256 \`

The -HashAlgorithm parameter specifies the algorithm used for hashing
during the certificate's creation (i.e., when signing the certificate).
**SHA256** is a secure and widely adopted hash function.

9.  **Validity Period**

-NotAfter (Get-Date).AddYears(10) \`

The -NotAfter parameter sets the expiration date of the certificate.
Using (Get-Date).AddYears(10) means the certificate will be valid for 10
years from the current date. Long-lived root certificates are common.

10. **Certificate Store Location**

-CertStoreLocation \"Cert:\\LocalMachine\\My\" \`

This parameter indicates where in the certificate store the new
certificate will be placed. \"Cert:\\LocalMachine\\My\" refers to the
personal store for the local computer account.

11. **Text Extension**

-TextExtension @(\"2.5.29.19={critical}{text}ca=true&pathlength=1\")

The -TextExtension parameter allows you to add custom certificate
extensions using a text-based format:

- **2.5.29.19** is the Object Identifier (OID) for the Basic Constraints
  extension.

- **{critical}** marks this extension as critical - if a client doesn't
  understand this extension, it should not trust the certificate.

- **{text}ca=true&pathlength=1** conveys that this certificate is a CA
  certificate (ca=true) with a path length constraint of 1, which limits
  the number of subordinate certificate issuers that can follow in the
  chain.

12. **Exporting the Certificate**

Export-Certificate -Cert \$rootCert -FilePath
\"C:\\Temp\\ContosoRootCA.cer\"

 Finally, this command exports the created certificate to a file
(containing the public portion of the certificate, i.e. without the
private key). The file is stored at C:\\Temp\\ContosoRootCA.cer in a
standard certificate file format (usually Base-64 encoded).

To summarize: This script creates a self-signed root CA certificate with
appropriate settings for a Certificate Authority: an exportable key
usable for signing operations, a strong cryptographic setup (RSA with a
2048-bit key and SHA256), and a defined validity period.

### Creating an Intermediate Certificate

As described above, we will create an intermediate certificate that is
signed with the root certificate we created above.

\# Create an Intermediate CA certificate (self-signed)\
\$rootSubject = \"CN=ContosoRootCA, O=Contoso, OU=IT, C=US\"

\$rootCert = Get-ChildItem -Path Cert:\\LocalMachine\\My \|\
    Where-Object { \$\_.Subject -eq \$rootSubject -and
\$\_.HasPrivateKey }

if (-not \$rootCert) {\
    Write-Error \"Root CA certificate with subject \'\$rootSubject\' not
found in LocalMachine\\My.\"\
    return\
}

\$intermediateCert = New-SelfSignedCertificate \`\
  -Subject \"CN=ContosoIntermediateCA, O=Contoso, OU=IT - Americas,
C=US\" \`\
  -KeyExportPolicy Exportable \`\
  -KeyUsage CertSign, CRLSign, DigitalSignature \`\
  -Type Custom \`\
  -KeyAlgorithm RSA \`\
  -KeyLength 2048 \`\
  -HashAlgorithm SHA256 \`\
  -NotAfter (Get-Date).AddYears(5) \`\
  -CertStoreLocation \"Cert:\\LocalMachine\\My\" \`\
  -Signer \$rootCert \`\
  -TextExtension @(\"2.5.29.19={critical}{text}ca=true&pathlength=0\")\
  

Export-Certificate -Cert \$intermediateCert -FilePath \"C:\\Temp\\.cer\"

This is what happens here:

1.  First we define the root subject.

\$rootSubject = \"CN=ContosoRootCA, O=Contoso, OU=IT, C=US\"

The \$rootSubject variable stores the distinguished name (DN) of the
root CA certificate that you previously created. The DN components
include:

- **CN (Common Name):** \"ContosoRootCA\"

- **O (Organization):** \"Contoso\"

- **OU (Organizational Unit):** \"IT\"

- **C (Country):** \"US\"

2.  Then we retrieve the root certificate from the Certificate store:

\$rootCert = Get-ChildItem -Path Cert:\\LocalMachine\\My \|\
Where-Object { \$\_.Subject -eq \$rootSubject -and \$\_.HasPrivateKey }

This command searches the local machine\'s personal certificate store
(Cert:\\LocalMachine\\My) for certificates that match the subject
defined in \$rootSubject and that also have an associated private key.
The private key is critical because you need it to sign the intermediate
certificate, establishing a chain of trust. If no matching certificate
is found, the script can't proceed with signing.

### Creating a User Certificate

Now the time has come to create the user certificate that is validated
by the intermediate certificate created above. Here is a PowerShell
script for creating it:

\# Edit the details as needed\
\$account = \"testuser\"\
\$tenant = \"Contoso\"\
\$userUPN = \"<$account@$tenant.onmicrosoft.com>\"\
\$subjectPrefix = \"\$account.\$tenant.\"\
\$subject = \"CN=\$subjectPrefix User Certificate, O=\$tenant, OU=Users,
C=US\"

\# Find the Intermediate CA in the cert store\
\$intermediateSubject = \"CN=ContosoIntermediateCA, O=Contoso, OU=IT -
Americas, C=US\"\
\$intermediateCert = Get-ChildItem -Path Cert:\\LocalMachine\\My \|\
    Where-Object { \$\_.Subject -eq \$intermediateSubject -and
\$\_.HasPrivateKey }

if (-not \$intermediateCert) {\
    Write-Error \"Intermediate CA cert not found in
Cert:\\LocalMachine\\My.\"\
    return\
}

\$userCert = New-SelfSignedCertificate \`\
  -Subject \$subject \`\
  -KeyAlgorithm RSA \`\
  -KeyLength 2048 \`\
  -HashAlgorithm SHA256 \`\
  -CertStoreLocation \"Cert:\\LocalMachine\\My\" \`\
  -Type Custom \`\
  -KeyExportPolicy Exportable \`\
  -TextExtension @(\
      \"2.5.29.19={critical}{text}ca=false\",  \# Basic Constraints (not
a CA)\
      \"2.5.29.37={text}1.3.6.1.5.5.7.3.2\",   \# EKU: Client
Authentication\
      \"2.5.29.17={text}email=\$userUPN\"       \# SAN: RFC822Name
(email)\
  ) \`\
  -Signer \$intermediateCert \`\
  -NotAfter (Get-Date).AddYears(1)\
 

Export-Certificate -Cert \$userCert -FilePath
\"C:\\Temp\\\$subjectPrefix-UserCert.cer\"

\$certpwd = ConvertTo-SecureString -String \'yourreqpwdhere\' -force
-AsPlainText

Export-PfxCertificate -Cert \$userCert -FilePath
\"C:\\Temp\\\$subjectPrefix-UserCert.pfx\" -password \$certpwd

 This script has these steps:

**User Identity Construction:\**
The script builds the necessary identity details (DN, UPN) for a user
certificate, ensuring consistency in naming. Note the certificate is
valid for 1 year after the date of the creation, which is a common
choice.

**Intermediate CA Integration:\**
It then locates an existing Intermediate CA certificate in the local
machine store. This is crucial because it will be used for signing the
new user certificate, maintaining a chain of trust.

**Certificate Creation:\**
With the identity and signer in place, the script creates a new
self-signed (but subordinate) certificate that is specifically intended
for client authentication. Custom text extensions clarify the usage and
ensure it cannot act as a CA.

**Export Process:\**
Finally, the certificate is exported both as a .cer file (public
information only) for distribution/validation and as a .pfx file
(including the private key, secured by a password) for import or backup
purposes.

 

### Importing the Root certificate

Now that we have generated the certificates it is time to configure the
Public Key Infrastructure (PKI) importing the root certificate.

1)  Go to the Entra admin center at http://entra.microsoft.com and sign
    in.

2)  After logging in, under the Protection tab, select Show More, then
    select Security Center.

3)  From there use the Create PKI button.

Once in the security Center, under Manage \> Public Key Infrastructure
(Preview), Click "Create PKI" button in the top corner and provide a
name for the PKI.

![A screenshot of a computer AI-generated content may
be incorrect.](Media/media/create-pki.png){width="3.6041666666666665in"
height="2.5104166666666665in"}

 Select the PKI created

![A screenshot of a computer AI-generated content may be
incorrect.](Media/media/pki.png){width="6.5in"
height="2.2576388888888888in"}

 

4)  Click +Add certificate authority

Select the root CA created above, and set \"Is this certificate
authority the root?\" = Yes as shown below:

![A screenshot of a certificate AI-generated content may be
incorrect.](Media/media/add-root-certificate.png){width="5.948746719160105in"
height="6.8134503499562555in"}

5)  Now do the same for the Intermediate one but set \"Is this
    certificate authority the root?\" = No
 
![A screenshot of a certificate AI-generated content may be
incorrect.](Media/media/add-intermediate-certificate.png){width="6.03209208223972in"
height="6.89679571303587in"}

Both certificates should be listed as shown below:

![A screenshot of a computer AI-generated content may be
incorrect.](Media/media/certificate-list.png){width="6.5in"
height="1.8256944444444445in"}

6)  Set up the Authentication Methods.  

Go to: Security Center \> Manage \> Authentication Methods

 ![A screenshot of a computer AI-generated content may be
incorrect.](Media/media/authentication-methods.png){width="6.5in"
height="3.5027777777777778in"}

And Select **Certificate-based authentication**. Then once in the form,
select **Enable**

And add in the group (we had created an Entra ID group for RSAT, and
added in a couple users)

![A screenshot of a computer AI-generated content may be
incorrect.](Media/media/authentication-settings.png){width="6.5in" height="2.35in"}

After adding in the Group, click on the **Configure** Tab

![A close-up of a computer screen AI-generated content may be
incorrect.](Media/media/authentication-settings-configure-tab.jpeg){width="6.5in"
height="2.452777777777778in"}

 Click **Add Rule**

 Select:

Certificate Issuer (Checked)

Then Filter CAs by PKI (optional) if you have a lot of certs

Select the Intermediate certificate

Select Multi-factor authentication

Affinity binding: low

![A screenshot of a computer AI-generated content may be
incorrect.](Media/media/authentication-binding-policy-rule.png){width="4.969443350831146in"
height="7.563555336832896in"}

Click **Add**. And then acknowledge the message:

 ![A close up of a sign AI-generated content may be
incorrect.](Media/media/authentication-binding-policy-ack.jpeg){width="6.5in" height="0.9125in"}

Then click save. This now enabled the Certificate Based Authentication
to be classified as MFA.

 ![](Media/media/certificate-based-authentication-settings.jpeg){width="6.5in"
height="3.2222222222222223in"}

### Installing the certificates on the computer running RSAT

On the Computer where you'll run RSAT, install the certs:

- Root CA certs only need installing if self-signed

 Import these to Local Machine \> Trusted Root Certification
Authorities: Root CA (.cer file) and Intermediate CA (.cer file) as
shown below:

Import into Local User \> Personal the PFX file for the user cert
(you\'ll need to provide the password)

Enable Auto Cert Login for the tenant

Edit the highlighted parts below for the tenant ID, and user certificate
subject, and run in PowerShell to create the registry entries.

 New-Item -Path
\"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Edge\\AutoSelectCertificateForUrls\"
-Force

 

New-ItemProperty -Path
\"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Edge\\AutoSelectCertificateForUrls\"
\`\
  -Name \"1\" \`\
  -Value
\'{\"pattern\":\"\[\*.\]microsoftonline.com/f30eb649-d49c-41bc-91af-139e4fd1d9f6\",\"filter\":{\"SUBJECT\":{\"CN\":\"testuser.Contoso.
User Certificate\"}}}\' \`\
  -PropertyType String -Force

### Configure RSAT

In this case the manual selection was used as the Authentication method.
We describe the methods in a later section of this document. 

It is important to provide the thumbprint from the user certificate.

 ![](Media/media/configure-rsat.jpeg){width="6.5in"
height="7.513194444444444in"}

![A screenshot of a computer AI-generated content may be
incorrect.](Media/media/configure-rsat-2.png){width="6.5in"
height="5.979861111111111in"}

When the "Test Connection..." button is clicked, the system should show
that the connection is successful:

 ![](Media/media/rsat-connected.png){width="4.229166666666667in"
height="1.9583333333333333in"}

# RSAT certification Modes

**Automated**: RSAT will configure registry entries for the policy
selection with each test case before running steps, such the CBA auth
flow callback from certauth will automatically select a matching user
policy. Note policies here store only as "current user" which is because
of permissions is required for local machine entries. It is advised that
no entries exist for local machine entries when using this option, such
if someone has been using predefined and made a single local computer
policy then manually delete this before running automated.

**Predefined**: This is if users cannot use automated but want to
control their policies themselves, like if filtering by subject from our
rule in RSAT will not work, then they can configure this themselves as
feasible. It may be challenging to make a general policy that can work
with all accounts, but it would be up to users to govern this then.
Predefined means RSAT does not touch policy entries in the registry at
all. This does give an option for configuring the policy not under
current users, but under the local machine to share between users.

**Manual**: RSAT will remove any policy entries when playing back a test
if one is there in advance, but only from the current user. This means
if they have a policy from local machine then execution does fallback on
this, so that should not be mixed. The manual method gives a window of
10 seconds for manually selecting the policy when certauth callback for
the selection of this.  

 

 

 

 
